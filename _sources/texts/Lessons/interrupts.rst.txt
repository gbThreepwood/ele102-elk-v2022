.. _L7_adc_pwm_interrupt:

*****************************************
Interrupts
*****************************************

.. role:: ccode(code)
        :language: c

Introduction
=============

A interrupt is some form of external signal which interrupts the main process of the microcontroller CPU. When an interrupt occurs the current execution state of the main process is stored, before a different process (the ISR, or interrupt service routine) takes over. When the interrupt service routine has completed, execution control is returned to the main process. By external signal we mean a signal which is external to the CPU, physically it can be internal or external to the microcontroller chip. E.g. it can be generated by the timeout of an internal timer in the MCU, or by the change of logic state on a external pin.

Interrupts are useful for making the system responsive to external events while avoiding constant polling of the possible external event sources. The ISR may simply set a flag, or publish a message in a event queue such that the main process can take appropirate action when it is ready to do so.

The first section of this lecture describes how and when the interrupts are preferable over polling techniques. The following sections explain how the interrupt mechanism works. The second half of the lecture notes, starting with the section "Management of Interrupts," describes the common problems and programming mistakes and their solutions in utilizing interrupts in typical microcontroller applications.


Timing in Microcontrollers
---------------------------

A timer is a specialized type of clock which is used to measure time intervals. A timer that counts from zero upwards for measuring time elapsed is often called a stopwatch. It is a device that counts down from a specified time interval and used to generate a time delay, for example, an hourglass is a timer.

A counter is a device that stores (and sometimes displays) the number of times a particular event or process occurred, with respect to a clock signal. It is used to count the events happening outside the microcontroller. In electronics, counters can be implemented quite easily using register-type circuits such as a flip-flop. [#f2]_

Timers are counters that can be programmed to perform a variety of functions. Following are the typical operation modes and possible applications of timers:

**1. Programmed operation:** A timer can be used as an alarm clock to generate predetermined time delays. The  microprocessor sets the count limit or initializes the counter and enables the count operation. The timer generates an interrupt when the count limit is reached indicating the end of the programmed delay period. This mode of operation utilizes the internal clock and it does not require an external connection.

**2. Gated or triggered operation:** The count operation is controlled by an external signal. There may be several options to start and to stop the counter. In gated mode, the counter is enabled while the external signal is active. A multi-purpose timer allows independent selection of events that start and stop the counter. These events can be a rising or falling edge of the external trigger signal or an internal start/stop command issued by the microprocessor itself. The timer can be programmed to generate an interrupt when the counter stops. The common applications of gated or triggered operation involve any kind of time measurements, such as, measuring revolution time of a motor to detect its rotation speed, or quantification of time-encoded signals.

**3. Clocked operation:** The counter clock is supplied by an external signal while the count operation is enabled by the microprocessor or another timer. The typical applications include quantization of frequency-encoded signals, or position information generated by linear or rotational encoders.

The specifications for a timer are directly related to the requirements of the application:


**1. Maximum clock frequency** determines the timing resolution. The internal clock frequencies available for timer operations depend on the microprocessor clock.

**2. Number of counter bits** determines the count range or the maximum time period that can be measured.

**3. Functionality:** Having a programmable timer does not necessarily mean that it will support all operation modes and gating or triggering options. You need to read the timer description to find out whether it is useful for your application or not. You may as well need additional features such as buffering of timer count results for motor speed measurements. A timer with buffered outputs can store the count result at the end of every motor revolution and re-start the counting process immediately.


**Watchdog timers** are special-purpose timers dedicated to ensure the proper execution of microcontroller functions. The processor is required to restart the watchdog timer before the preset timer period expires and it repeats this operation as long as the watchdog function is enabled. The program written for the processor includes the necessary statements to restart the watchdog timer periodically. If the processor fails to restart the watchdog timer, then this indicates a major functional failure due to corrupt program memory or some other reason. In this case, the watchdog timer resets the processor, forcing initialization of all microcontroller functions [#f1]_.


Interrupts in Arduino
----------------------
There are some important keynotes `About Interrupt Service Routines <https://www.arduino.cc/reference/en/language/functions/external-interrupts/attachinterrupt/>`_ in Arduino. 

Properties of ISR (Interrupt Service Routine):

#. Global variables used in an ISR must be :code:`volatile`.
#. Should normally be fast and short functions.
#. No delay in the interrupt.
#. An ISR cannot have parameters - no input argument, no output return.
#. Stops **everything** in the main function.
#. :code:`millis()` doesn't work properly, :code:`delayMicroseconds()` works since it does not use any counter.



External Interrupts
===================

In the following examples we will be using this circuit:

.. figure:: ../../fig/three_button_and_three_led_bb.png
  :alt: Three buttons and three LED's
  :scale: 50

External interrupts are created by sensors (via communication channels) or buttons.

In Arduino an external interrupt handler is defined by the function:

.. code-block:: c

   attachInterrupt(digitalPinToInterrupt(pin), ISR, mode)


Practical exercises
--------------------

**Practical exercise:** Modify the RGB-LED code such that the blinking should stop immediately as soon as the button is pressed and should continue again as soon as it is released.


Although we are using the :code:`delay()` function in almost everywhere, it is a very dangerous function. It halts any processing completely. No reading of sensors, mathematical calculations, or pin manipulation can go on during delay function.

    
**Exercise for home:** Modify the interrupt code without using delay functions. There is a very nice project using an LCD here: 

..  `this link <https://www.youtube.com/watch?v=TD-J7LgrsBQ>`_.

.. youtube:: https://www.youtube.com/watch?v=TD-J7LgrsBQ


External interrupt request 0 and 1
----------------------------------

The external interrupt requests INT0, and INT1 are triggered by pin 2, and 3 respectively. The following program illustrates how the interrupst may be used to toggle the state of two digital outputs.

.. literalinclude:: ../../../projects/interrupt/external_interrupt/src/main.cpp
  :language: c

Pin change interrupts
---------------------

.. note:: The pin change interrupts are not supported by the Arduino library, and thus requires manual register manipulation.

The Atmega 328 does not support individual interrupts on all the digital inputs. The pin change interrupts in the Atmega 328 are three interrupt vectors that can be configured to trigger on the change of one or more of a range of input pins. This is often sufficient to make a responsive application, because the ISR can check wich of the input pins that have changed, and thus wich one is responsible for the interrupt. Often the ISR will simply change a flag, or post a message into a queue, and the main process will then take appropirate action when it is ready.

The following code shows a function that configures Arduino pin 11, 12, and 13 for pin change interrupt:

.. code-block:: c

        /*
         * Arduino pin 13, 12, and 11 are connected to PCINT 5, 4, and 3.
         */
        void interrupt_setup(){
        
          // Enable pin change interrupts PCINT3, PCINT4, and PCINT5.
          PCMSK0 |= ((1 << PCINT5) | (1 << PCINT4) | (1 << PCINT3));
        
          // Clear any interrupts on ISR0.
          PCIFR |= (1 << PCIF0);
        
          // Pin Change Interrrupt Control Register (PCICR)
          PCICR |= (1 << PCIE0);
        
          sei();
        }


The actual code that is executed upon a interrupt is defined as follows:

.. code-block:: c

        
        // Pin change ISR for D8 to D13
        ISR (PCINT0_vect){
          
          // Code to detect which pin is responsible for the interrupt. 
               
        }


Pin change interrupt example
----------------------------

The following example shows how to use all three pin change interrupts. Each ISR is responsible for toggling the state of a LED in order to indicate that the program is functional.

.. literalinclude:: ../../../projects/interrupt/pin_change_interrupt/src/main.cpp
  :language: c

Internal Interrupts
===================

Internal interrupts are interrupts that are triggered by the internal hardware (or software) of the microcontroller. Internal interrupt sources includes timers, various communication hardware such as UART, and software that writes to a interrupt request register. 

Timer controlled interrupts
---------------------------

All timers depends on the system clock of your Arduino system. Normally the system clock is 16MHz, but for the Arduino Pro 3,3V it is 8Mhz. So be careful when writing your own timer functions.
The timer hardware can be configured with some special timer registers. In the Arduino firmware all timers were configured to a 1kHz frequency and interrupts are gerally enabled.

**Timer0** is a 8bit timer. In the Arduino world timer0 is been used for the timer functions, like delay() 484, millis() 1.1k and micros() 497. If you change Timer0 registers, this may influence the Arduino timer function. So you should know what you are doing.


**Timer1** is a 16bit timer. In the Arduino world the Servo library 811 uses Timer1 on Arduino Uno (timer5 on Arduino Mega).

**Timer2** is a 8bit timer like Timer0. In the Arduino work the tone() 650 function uses Timer2.

Timer3, Timer4, Timer5 are only available on Arduino Mega boards. These timers are all 16bit timers. [#f3]_

.. note:: Since internal timers are created by changing the Timer behaviour through the timer register, we will not cover it here. This subject requires at least intermediate embedded programming skills and datasheet reading. However, this is one of the most important topics in the embedded systems. For those who are willing to learn this topic should know about setup and Use of the Timers* (`AVR130: Setup and Use the AVR Timers <http://ww1.microchip.com/downloads/en/AppNotes/Atmel-2505-Setup-and-Use-of-AVR-Timers_ApplicationNote_AVR130.pdf>`_.


.. note::
   :code:`interrupts()` and :code:`noInterrupts()` are used to enable and disable interrupts respectively. They are used for the critical parts of the code. - https://www.arduino.cc/reference/en/language/functions/interrupts/interrupts/. Alternatively the functions :code:`sei()`, and :code:`cli()` may also be used.


Timer 1 interrupt example
--------------------------

.. note:: The following example uses the TimerOne library for controlling Timer 1. Depending on your development environment you may have tomanually install the library.

.. literalinclude:: ../../../projects/interrupt/timer_interrupt/src/main.cpp
  :language: c

Watchdog timer interrupt
------------------------

The purpose of the watchdog timer is to reboot the controller if the program should crash. It is a safeguard for poorly designed programs, but even well designed programs may crash if the controller is exposed to external noise (radiation) that messes with the memory.

.. literalinclude:: ../../../projects/interrupt/watchdog_timer_interrupt/src/main.cpp
  :language: c

**Practical Exercise:** Let's write a program with an RGB light, blinking each LED for 1 second (reg, green, blue, white) and repeat it infinitely. Also, attach a button that stops blinking of all LEDs. Do not use any interrupt knowledge at first and let's see what happens. Afterwards, define your button as an interrupt and see what changes.


Detailed look at the operation of the interrupt system
-------------------------------------------------------


Switch debounce methods
=================================

Switch bounce is the mechanical bouncing of the contacts in an electrical switch, causing what should be a single event to appear to be multiple events (e.g. multiple presses of a push button). It is a feature of most electical swiches, and causes problems when the swiches are interfaced with fast digital electronics, such as microcontrollers. Many solutions have been developed to overcome these issues, and thus it is impossible to cover all of them. This chapter aims to provide you with some effective hardware and software solutions.

.. warning:: The part about switch debounce is not ready.

Measuring switch bounce using oscilloscope
------------------------------------------

Hardware solutions
------------------


Software solutions
------------------

Switch debounce in hardware is a effective solution, but additional hardware increases the cost and thus it is often possible to save some cost by implementing software debounce. Switch change may be detected by polling the state of the digital input, or the input may generate an interrupt to the CPU. Regardless of which metod one is using, care must be taken to not detect several push events because of bouncing.

Polling is often the preferred method to detect push buttons, although constant polling does waste some CPU cycles. In applications such as battery operated devices, the microcontroller could be put into a sleep state in order to save power when it is not in use. A interrupt is often required to wake up the controller, but afterwards in could enter a polling mode for the inputs. In simple applications the polling could be acheived in the main loop, or by using a timer interrupt where the ISR polls the inputs. If the controller is running a operating system, it could also be possible to use a thread for the polling.

The interrupt solution requires extra attention because the bouncing in some cases may cause the ISR to fire many times within a short time period. This can have a bad impact on the performance of the microcontroller. The solution will often be that the pin change interrupt is temporary disabled by the ISR on the first invocation. After some delay the interrupt is re-enabled.

Because many applications require debouncing of more than one push button, it is often useful to create a library which provides a consistant way of adding debounce to the inputs that require this.

Measure the bouncing using interrupt
------------------------------------

A oscilloscope is a good tool for evaluating the bouncing problemens of a push button. If you do not have access to a oscilloscope, it is also possible to use the controller itself to measure the bouncing. This method is less accurate, because the voltage levels during the bouncing period may vary, and only occationally cause spurious detection of button events.

The following example is using a pin change interrupt to count the bouncing of the signal on a digital input. Note that the ISR fires on both rising and falling edge of the signal, thus you will at least trigger the ISR once on button push, and once on button release.

.. literalinclude:: ../../../projects/interrupt/pin_change_switch_bounce_counter/src/main.cpp
  :language: c



Delay method
------------

The following method checks for a rising edge on the digital input, and subsequently ignores any change of state for a given delay period. A important issue with this method is that the required delay period will vary depending on the type of switch that i used.

.. literalinclude:: ../../../projects/switch_debounce/delay_switch_debounce/src/main.cpp
  :language: c

Shift register method
---------------------

The following example is intended to demonstrate the operation of the shift register debounce method, by printing the state of the shift register to the UART. The shift register method is in some ways superior to the delay method, because it will detect if the input is stable rather than simply detecting a edge, and ignoring the input for some period. The sampling delay for the shift register method may be much shorter than the delay for the delay method.

.. literalinclude:: ../../../projects/switch_debounce/shift_register_switch_debounce/src/main.cpp
  :language: c


Using a timer interrupt to poll the inputs
-------------------------------------------

The following example shows one way to poll three digital inputs using a timer interrupt. The :ccode:`get_button_event(push_button_t button)` function is included in order to abstract away the operation of the button event detect algorithm. This is a more complete example of how to use debouncing in an application, but it could certainly be improved. In particular the operation of the switch debounce could be hidden in a separate file (a library), and the events could be posted to a queue.

.. literalinclude:: ../../../projects/switch_debounce/timer_polling_switch_debounce/src/main.cpp
  :language: c

Pin change interrupt debounce with smoothing capacitor
------------------------------------------------------

.. warning:: You should avoid the pin change interrupts for push buttons, unless you are absolutely sure that you need it. The aforementioned methods are simpler to implement, and more general in nature. The pin change interrupt is a specific feature of some of the AVR controllers.
  
  The problem with using interrupts with switch inputs is that bouncing will cause the ISR to fire multiple times, unless the ISR disables the interrupt on the first invocation. This complicates things.

Pin change interrupt debounce software only
-------------------------------------------

In this section we are demonstrating one way of detecting and debouncing inputs using pin change interrupts. The following algorithm is used:

.. uml::

  (*) --> "ISR fires on one of the inputs"
  --> "Check wich input caused the interrupt"
  --> "Set flag, or post message"
  --> "Disable the pin change interrupt"
  --> (*)

.. uml::

  (*) --> "Main loop or timer checks for new events"
  If "New event" then
  --> [Yes] "Store"
  else
  --> (*)
  Endif

  
.. literalinclude:: ../../../projects/interrupt/pin_change_interrupt_switch_debounce/src/main.cpp
  :language: c

Creating a library for software debounce
----------------------------------------


.. rubric:: References
.. [#f1] Izmir Institute of Technology - Department of Electrical and Electronics Engineering *EE443 - Embedded Systems lecture notes - 2013*
.. [#f2] https://www.tutorialspoint.com/embedded_systems/es_timer_counter.htm
.. [#f3] https://www.robotshop.com/community/forum/t/arduino-101-timers-and-interrupts/13072

