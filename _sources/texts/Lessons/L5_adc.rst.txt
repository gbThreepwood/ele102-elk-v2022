.. _analog_to_digital_conversion:

*******************************************************
Analog to digital conversion (ADC)
*******************************************************

In the previous lesson we discussed digital to analog conversion. In this lesson we consider the opposite process, where a analog signal is converted in to a digital representation.

In order to be prepared for all the exercises in this lesson, the following connections should be made in advance:

.. figure:: ../../fig/fritzing/arduino_pb_led_pot_tmp36_bb.png
  :alt: Arduino with external LED, push buttons, potentiometer, and TMP32 temperature sensor.
  :align: center
  :scale: 50

.. As we discuss about how to convert something digital into something analog, now it is time to talk about the opposite!

Introduction
====================================

.. Analog input and output concept in Arduino is a bit more challenging than digital. In this lecture, we will dive into it.

.. .. todo:: Make an introduction of what is analog i/o, why do we need ADC/DAC?

Analog to digital converters (ADC) and digital to analog converters (DAC) are
the bridges between digital and analog worlds.

The analog to digital converter has many applications, some of which include:

* Reading of potentiometer settings
* Reading of temperature sensors, pressure sensors, light sensors, strain sensors, etc.
* Reading the voltage on a battery in order to determine the state of charge (sometimes combined with a temperature reading, since battery voltage can be affected by temperature)
* Measurement of EMF in order to determine the rotational speed of a motor
* Measurement of voltage and current in power systems in order to calculate active (P), and reactive (Q) power.
* Reception of radio signals for use in a software defined radio (SDR)

Analog to digital converter
---------------------------

An A/D converter (analog to digital converter) is a device that converts a analog signal into an approximate digital representation. Many different technologies exits for this purpose, where each one has it's own advantages and disadvantages. The following is a list of the more common types:

* Successive Approximation (SAR) ADC.
* Delta-sigma (ΔΣ) ADC.
* Dual Slope ADC.
* Pipelined ADC.
* Flash ADC

The Atmega328p of the Arduino UNO has a successive approximation ADC, and the operation of this type of converter will be discussed briefly. The other types will not be discussed further in this lecture.

Successive Approximation (SAR) ADC.
-----------------------------------

.. figure:: ../../../external/fig/adc/sar_block_diagram.png
        :align: center

The successive approximation ADC uses a binary search method to go through all possible quantization levels for the digital representation for the analog value, until it finally reaches the best approximation.

The analog value is sampled, and a constant voltage sample is held in the sample and hold (S/H) circuit. This voltage sample is then compared to the output voltage from a digital to analog converter (DAC), which initially is set to zero volts. The comparator then informs the successive approximation register whether the sampled voltage is above or below the DAC output. If the sampled voltage is higher than the DAC output, the successive approximation register increase the DAC output on the next clock cycle. This process continues on each clock cycle until the DAC output becomes higher than the sampled value.

The digital signal which is required to control the DAC in such a way that it outputs a voltage approximately equal to the sampled voltage, is then used as the digital representation of this analog voltage. The end of conversion (EOC) signal informs the processor that the conversion process is completed.

It should be obvious from the above explanation that the analog to digital converter needs some time to complete the conversion process. The time it takes to complete one conversion is one of the fundamental parameters describing an ADC.

Important parameters for ADC operation
--------------------------------------

There are many important parameters one should understand when applying an A/D converter. Even if a particular ADC is selected, there are still many parameters that can be adjusted within the ADC depending on how you intend to use it. The following is a summary of a few basic ones:

* Resolution - The digital representation of the analog signal must use a finite number of bits, and this imposes limitations on the smallest possible change in the analog value that is detectable by the converter.
* Sampling frequency - The conversion from analog to digital takes up a finite time, and this imposes limitation on how fast changes in the analog signals that are detectable.
* `Aliasing <https://jeelabs.org/article/1620b>`_ - If the measured analog signal contains components with a frequency that is higher than half of the sampling frequency, there is a risk of aliasing. The risk is that the resulting digital representation contains frequency components that does not exist in the real analog signal.
* Dymaic range -  The range of signal amplitudes that the ADC can resolve.

For simple applications with values that vary slowly (e.g. temperature measurements), it might be sufficient to only take these parameters into account. For more demanding applications (e.g. real time current measurements in a motor drive), one should obtain a deeper knowledge of all the parameters that will impact the performance. 

.. ref: https://web.ics.purdue.edu/~jricha14/Port_Stuff/PortA_ADC.htm

.. But before that, let's talk about bit manipulation and binary operations. Detailed readinng `here <https://binaryupdates.com/bitwise-operations-in-embedded-programming/#Bitwise_Shift_Operators_ltlt_gtgt>`_.


The analog input or output range is determined by a reference voltage, :math:`V_{ref}`. Typically for an N-bit converter with
unsigned digital I/O and unipolar analog range :math:`(0V .. +V_{ref})`, one step at the analog
end, :math:`\Delta V_{LSB}`, is given by:

.. math::
    \Delta V_{LSB} = \frac{V_{ref}}{2^N}

Similarly for a bipolar analog range :math:`(-V_{ref} .. +V_{ref})`, one step at the analog end is:

.. math::
    \Delta V_{LSB} = \frac{V_{ref}}{2^N}


Using the ADC in Arduino
========================

The Arduino UNO has six analog inputs on the pins A0 to A5. There is only a single ADC, but some internal switches allows us to select which of the inputs is sampled. By default the voltage range on each input is 0 - 5 V.

In the Arduino library the function :code:`analogRead()` can be used to read data from the ADC. E.g. :code:`analogRead(A0)` in order to read the first analog input. This is a blocking function, meaning the program will stop and wait for the conversion process to complete before the function returns. The ADC has a resolution of 10 bit, which means that the value returned from :code:`analogRead()` will be a number between 0, and 1023. There is no 10 bit datatype, and in the function declaration the return type is set to :code:`int`, which is a 16 bit signed number on the Arduino UNO. In reality it can never be negative, and thus a unsigned int, or :code:`uint16_t` could have been used.

The ADC will convert the analog input voltage (0 - 5 V) in to a number (0 - 1023). If you are interested in knowing the voltage level, some basic calculations has to be performed after the conversion is completed.

If the number returned from :code:`analogRead()` is 400, the voltage is given by:

.. math::
	V = \frac{400}{1023} \cdot 5 = 1.955 V

You should also consider how many significant figures you can have in this number. I.e. how many volts do you have per bit.

.. math::
	\frac{5 V}{1023} = 4.888 mV/bit

The conversion time is approximately 100 microseconds, which means that it is possible to perform 10000 conversions each second. This is not the absolute maximum speed of the ADC, it is simply how the ADC is configured inside the Arduino library.

Exercise: print raw ADC value to serial port
--------------------------------------------

In this exercise you will experience how various voltages applied to analog input A0 affects the value returned from :code:`analogRead()`.

#. Write a simple program that is able to print a message to the serial port at a given interval. Use :code:`millis()` to obtain the delay, and use a interval of 2 seconds.
#. Extend the program so that the value printed to the serial port is the raw value returned from :code:`analogRead()`.
#. Test the program by applying various voltages to the A0 port. Try 5 V, 3.3 V, GND, and optionally a resistive voltage divider using two resistors.

Example: Temperature measurement using TMP36
--------------------------------------------

In this example we will be reading the temperature from the TMP36 sensor that is included in the Arduino kit. The TMP36 has a voltage output linearly proportional to the temperature, and thus makes it easy to measure temperatures without any curve fitting that must be used with nonlinear sensing elements.


The details of how the TMP36 operates are available in the `datasheet <https://www.analog.com/media/en/technical-documentation/data-sheets/TMP35_36_37.pdf/>`_

Connect the sensor according to the following diagram:
  
.. figure:: ../../fig/temperature_sensor_bb.png
        :align: center
        :scale: 50

The following source code listing shows how to read the sensor, and how to convert the raw reading to voltage, and temperature:

.. note:: Try to change the program to use :code:`millis()` instead of :code:`delay()`.

.. code-block:: c

	#include <Arduino.h>
                
	void setup() { 
		Serial.begin(9600); 
	}

	void loop() {
		int sensorVal = analogRead(A0);
		float sensorVolt = (sensorVal/1024.0)*5;
		float temperature = (sensorVolt - 0.5)*100;

		Serial.print("Sensor verdi: ");
		Serial.print(sensorVal);
		Serial.print("\n");

		Serial.print("Sensor spenning: ");
		Serial.print(sensorVolt);
		Serial.print("\n");

		Serial.print("Sensor temperatur: ");
		Serial.print(temperature);
		Serial.print("\n");
		delay(2000);

	}

Exercise: Change the unit of temperature measurement
----------------------------------------------------

#. Use the program in the previous example as basis, and add the code required to print the temperature in Kelvin to the serial port.
#. Extend the program by printing the temperature in Fahrenheit, and Rankine.

Example: Potentiometer as Analog Input
--------------------------------------

A potentiometer is a type of variable resistor with 3 connections. Two of the connections are placed at the extreme ends of the resistor, for ease of discussion we will name them connector (1), and (2). I.e. the resistance between pins (1), and (2) is always equal to the maximum resistance of the variable resistor. The third connector (3) is connected to a sliding contact, which moves along the resistor. At one extreme end this sliding connector is at (or close to) connector (1), at the other extreme it is at connector (2).

By applying a fixed voltage between connector (1), and (2), the voltage at the sliding contact (3) will vary linearly with the rotation of the potentiometer knob.

.. How does a dimmer light work? Well, you don't need a microcontroller for *just* changing the light luminosity, for sure. The key element you got to know here is a **potentiometer**. It simply divides the voltage on its two legs between the middle leg. You may or may not use the both legs depending on your purpose.


.. figure:: ../../../external/fig/simple_pot_battery.png
   :alt: Simple potentiometer circuit
   :align: center


You can use this potentiometer value for various different purposes. Now, assume that your microcontroller team is assigned to develop a simple heat display system. If the temperature is higher than 30 celcius, the display gives a warning. If it is between 20-30 celcius, everything is fine. If it is less than 20 celcius, then your display system warns again. To have a temperature sensor (in real life) and physically change the temperature of the room for the sake of test is not very efficient. *We all know* that temperature sensor gives an analog signal so I can test the system using a potentiometer to emulate the sensor.

.. Let's change the temperature sensor with a potentiometer assuming that the potentiometer is the temperature sensor.

For this example you should use the following circuit:

.. figure:: ../../../external/fig/simple_pot_arduino.png
   :alt: Simple potentiometer circuit with Arduino
   :align: center


.. code-block:: c

	void setup() {
		Serial.begin(9600);
	}

	void loop() {
		int sensorVal = analogRead(A0);
		float sensorVolt = (sensorVal/1024.0)*5;
		float temperature = (sensorVolt - 0.5)*100;

		Serial.print("Raw value: ");
		Serial.print(sensorVal);
		Serial.print("\t");

		Serial.print("Voltage: ");
		Serial.print(sensorVolt);
		Serial.print("\t");

		Serial.print("Temperature: ");
		Serial.print(temperature);
		Serial.print("\n");

		if(temperature >=30)
			Serial.print("Warm");

		else if((temperature >=20)&&(temperature <30))
			Serial.print(":)");

		else
			Serial.print("Cold");

		delay(1000);

	}

.. note:: After you have finished testing the software using a potentiometer to emulate the temperature sensor, you should connect a real temperature sensor for the final test. There is always a risk that there is something you did not take in to account when performing the emulated test.

Exercise: Potentiometer adjustable blink rate
---------------------------------------------

In this exercise you will develop a program which allows adjusting the blink rate (frequency) of a LED by means of a potentiometer.

#. Write a program which blinks a LED using :code:`millis()` for the delay.
#. Connect a potentiometer to input A0, and add the code required to sample the potentiometer value at a rate of 10 milliseconds.
#. Use the potentiometer value to control the blink frequency of the LED. The minimum setting should be 0.5 Hz, and maximum should be 25 Hz.

Exercise: Temperature alarm (challenging)
-----------------------------------------

In this exercise you will expand the temperature reading example in to a program that generates a alarm signal if the temperature exceeds a level of 27 degrees. The temperature alarm limit is set to this value so that it will be easy to test, it is above the typical room temperature, but below the body temperature (or the temperature of your coffee).

#. Start by connecting the TMP36, as well as a push button, and a red LED to the Arduino.
#. Write a program which continuously reads the temperature value, and compares it to a alarm limit defined by a constant variable. Use :code:`millis()` instead of :code:`delay()` for delaying the execution time for the sampling. Use a interval of 1 second. For easy debugging the actual temperature value should be printed to the serial terminal at each sampling interval.
#. Extend the program with the code required to initiate blinking of the LED, and printing of the text "Temperature alarm!" to the serial port as soon as the temperature exceeds the limit. The alarm should not stop, even if the temperature goes back down again below the alarm limit.
#. Add an alarm acknowledge push button function. If the button is pushed, and the temperature is below the alarm limit, the LED blink, and alarm message should go away. For this functionality debouncing is not needed, as acknowledging an already acknowledged alarm will not perform any action.

Detailed look at the Atmega328p ADC
===================================        

In the ADC hardware of the Atmega328p, there are many different parameters that needs to be configured properly. For example setting the ADC speed, resolution, conversion mode etc. By using the :code:`analogRead(analogPin)` Arduino function without changing anything, we simply accept the parameters that the Arduino developers hav selected for us. The default settings are fine for basic usage, but there are many situations where you would have to go in to the details.


Voltage reference for the ADC
-----------------------------

As discussed previously, the analog to digital converter uses a voltage reference for comparison with the analog signal it is converting. The Atmega328p microcontroller has several options for where to obtain this reference. In the Arduino UNO library these reference options may be set by the :code:`analogReference()` function, which takes the parameters `DEFAULT`, `INTERNAL`, or `EXTERNAL`, for 5V, 1.1V or externally applied voltage to the AREF-pin respectively. The selected reference voltage will be the maximum input voltage for the ADC, i.e. the voltage that will correspond to the digital value of 1023.

.. code-block:: c

        analogReference(EXTERNAL);

If you are only interested in measuring voltages from 0 - 2 V, a external reference of 2 V will provide better resolution than the default reference of 5 V.

The accuracy of the reference voltage directly affects the accuracy of the converted voltage, and this is another motive for using an external reference. By accuracy in this context we mean: how sure can you be that the voltage actually is 5 V, is it 5.00 V, or could it be 5.02 V? A highly precise reference voltage can be used if high accuracy is required.

..
    Light intensity measurements using a phototransistor
    ----------------------------------------------------

    https://www.arduino.cc/documents/datasheets/HW5P-1.pdf


    Voltage reference experiment using potentiometer
    ------------------------------------------------

    In this example we will be using two potentiometers, one for adjusting the voltage reference, and one for adjusting the input voltage to the ADC.



ADC conversion speed
--------------------

The conversion speed is determined by the clock signal to the successive approximation register in the ADC. There is a maximum limit to this clock, after which the ADC starts misbehaving. The recommended maximum clock speed is 200 kHz, while the specified absolute maximum speed is 1 Mhz.

In the Arduino library the clock is derived from the CPU clock by using a prescaler of 128

.. math::
	\frac{16 Mhz}{128} = 125 kHz

Each conversion takes 13 ADC clock cycles, which yields a sample rate of:

.. math::
	\frac{125 kHz}{13} = 9615 Hz

The conversion time is thus given by:

.. math::
	\frac{1}{9615} = 104 us

This corresponds well with the conversion time stated in the documentation for the :code:`analogRead()` function in the Arduino library.

Low level control of the Analog to Digital Conversion
-----------------------------------------------------

Here is an example of the implementation of ADC without using built-in :code:`analogRead(analogPin)` function. There are different ways of bitwise operations. It is better to be consistent in using one way but here we would like to see different ways. Let's understand it with the help of Atmega328p datasheet.

.. literalinclude:: ../../../projects/ADC_full/ADC_full.ino
   :language: c


.. note::

   ADC is a demanding topic also requires basic signal processing knowledge. One should read about possible errors before computing a serious analog to digital conversion. `Here, <https://www.maximintegrated.com/en/design/technical-documents/tutorials/6/641.html>`_ is a very nice summary of general ADC problems. 

.. The ATmega controllers used for the Arduino contain an onboard 6 channel (8 channels on the Mini and Nano, 16 on the Mega) analog-to-digital (A/D) converter. The converter has 10 bit resolution, returning integers from 0 to 1023. The default input voltage range is 0 - 5V, thus 5V corresponds to 1023. By default the maximum sampling frequency of the Arduino UNO is 9615 Hz. It is however possible to increase this by modifying the ADC clock frequency.

While the main function of the analog pins for most Arduino users is to read analog sensors, the analog pins also have all the functionality of general purpose input/output (GPIO) pins (the same as digital pins 0 - 13). Consequently, if a user needs more general purpose input output pins, and all the analog pins are not in use, the analog pins may be used for GPIO.


.. warning:: 
   The analogRead function will not work correctly if a pin has been previously set to an output, so if this is the case, set it back to an input before using analogRead. Similarly if the pin has been set to HIGH as an output, the pull-up resistor will be set, when switched back to an input.
   
   The ATmega datasheet also cautions against switching analog pins in close temporal proximity to making A/D readings (analogRead) on other analog pins. This can cause electrical noise and introduce jitter in the analog system. It may be desirable, after manipulating analog pins (in digital mode), to add a short delay before using analogRead() to read other analog pins.


Increasing resolution by oversampling
-------------------------------------

.. todo:: Explain how to use oversampling (and why it works)