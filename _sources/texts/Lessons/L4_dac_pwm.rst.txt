.. _dac_pwm:

*******************************************************
Analog output (digital to analog conversion)
*******************************************************


Digital to analog converter
=============================

.. todo:: Add graph of discrete samples, and DAC output.

A digital to analog converter is a device which converts a digital representation of a signal in to a real physical signal, typically a voltage. The digital representation is just a number, which has discrete steps in it's value, while the analog signal is capable of continuous variation [#f10]_.

.. rubric:: Footnotes

.. [#f10] In reality the digital representation is also analog. It is analog in the sense that the computer exists in a analog universe, but it does not matter if the computer uses 0 V and 5 V, 0 V and 3.3 V, or some other voltage levels to represent the binary values. Either way the interpretation of the digital value should be the same. 


.. .. todo:: More ADC examples with LED and if...else


Pulse Width Modulation (PWM)
=============================

.. todo:: Graph over PWM curve

What is Modulation?

What is a pulse?

.. note::
   Blackboard explanation.

Analog output by PWM
---------------------

As already discussed, analog output from a microcontroller (or any digital system) is performed by means of a Digital to Analog Converter (DAC). The Atmega328p of the Arduino UNO does not have a dedicated DAC built in to the device, but it has another feature which allows us to perform a crude digital to analog conversion [#f11]_. The feature is known as pulse width modulation, and basically means that we are switching one of the digital outputs on and off quickly, but with variation in the durations the output stays high and low. This allows us to control the average output voltage. By using some external components for filtering, this pulsating voltage can be converted to a steady voltage with a value corresponding to the average of the PWM signal.

You may wonder why pulse width modulation is a special feature in the microcontroller, only available on some pins. As you know from the previous lessons, any GPIO pin is capable of switching between the two voltage states representing *high*, and *low* (5 V, and 0 V on the Arduino UNO). It is indeed possible to generate PWM on any GPIO, and there are examples on situations where switching a generic GPIO in this way is desirable. The problem is that this switching is controlled by the software, taking up a certain amount of the available CPU time. If the switching frequency is supposed to be high, it will leave little room for the microcontroller to be working on other tasks besides the PWM. Additionally having multiple PWM outputs in this way increases the load even further. For this reason dedicated hardware support for PWM in included on some pins of the microcontroller. You simply configure the PWM, and the output will be running continuously with your settings, until it is changed from software. The reason only some pins have PWM is simply to reduce cost, there are other more powerful microcontrollers which support PWM on any pin.

Alternatively if you need "real" analog output you may use an external chip, that the Arduino may control by a digital bus such as I2C.


.. rubric:: Footnotes

.. [#f11] In reality the PWM DAC does not necessarily have to be considered a crude way to convert from digital to analog. It all depends on the switching frequency, and the analog filtering which is applied.

Operation of a pulse width modulator
------------------------------------

.. This section introduces the pulse width modulation outputs. It is a way of how to trick the having such an output that its value is so-called in between 0-5V. 

In this section we will cover the basics of how the PWM-outputs on the Atmega328p are operating.

.. TODO:: Figure from datasheet

The Arduino function associated with analog output signals that we will be using in this tutorial are:

- `analogWrite() <https://www.arduino.cc/reference/en/language/functions/analog-io/analogwrite/>`_

.. Now we will be pulling up the hood, looking under the hood, digging deeper, pulling back the onion!


The function in the Arduino library used to output a PWM signal is :code:`analogWrite(pin, value)`. *pin* is the pin number used for the PWM output. *value* is a number proportional to the duty cycle of the signal. When value = 0, the signal is always off. When value = 255, the signal is always on. On the Arduino UNO, the PWM function is available on pins 3, 5, 6, 9, 10, and 11. The frequency of the PWM signal on most pins is approximately 490 Hz. On the Uno and similar boards, pins 5 and 6 have a frequency of approximately 980 Hz. Pins 3 and 11 on the Arduino Leonardo also run at 980 Hz. The Arduino library does not support changing this frequency, but it is possible to do so by directly manipulating the registers of the Atmega328p hardware.

Mapping signals with different dynamic range
--------------------------------------------

Suppose your input signal has a range of 0 - 1023, and you need to drive the PWM which expects a value of 0 - 255. The larger dynamic range input signal needs to be *mapped* to the low dynamic range parameter of the PWM control signal. In order to achieve this one may use the following generic equation, where *x* is the input, and *y* is the output signal:

.. math::
    y = \frac{(x - x_{min}) \cdot (y_{max} - y_{min})}{(x_{max} - x_{min})} + y_{min}

For our example, this yields:

.. math::
    y = \frac{(x - 0) \cdot (255 - 0)}{(1023 - 0)} + 0 = x \cdot \frac{255}{1023}

The Arduino library has a built in function for the mapping of one signal over to another with a different range. But as you have seen from the above example it might be just as easy to do the calculations on your own. Anyway the function definition in the library is as follows:

.. code-block:: c

    long map(long x, long in_min, long in_max, long out_min, long out_max)
        {
          return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }


Hence to map an analog input value, which ranges from 0 to 1023 to a PWM output signal, which ranges from 0 - 255, you can use the :code:`map(value, 0, 1023, 0, 255)` function. This function has five parameters, one is the variable in which the analog value is stored, while the others are 0, 1023, 0 and 255 respectively. 

The :code:`long` variable type used it the function has the same size as :code:`int32_t`.


Exercise: Adjusting the light intensity of LED
----------------------------------------------

.. image:: ../../fig/single_led_bb.png
        :alt: Single external LED
        :scale: 50
        :align: center


In this exercise we will adjust the light intensity of a single LED by means of PWM.

#. Connect a LED in accordance with the figure. If you already have a LED connected, you only have to make sure it is connected to one of the pins which support PWM.
#. Write a simple test program where :code:`analogWrite(pin, value)` is used to control the pin connected to the LED. Try with various values for the :code:`value`, e.g. 64, 128, 255.
#. Extend the program so that a digital input connected to a push button changes the intensity of the LED. When you push the button it should change the duty-cycle from 64, to 128.

Exercise: Continuously adjusting the light intensity of LED
-----------------------------------------------------------

#. Write a program which increase the light intensity by pushing button 1, and decrease by pushing button 2.


Exercise: Adjusting the light intensity of multiple LEDs
--------------------------------------------------------

.. **ANNOUNCE:** If you have, use RGB-LED instead. 

In this example we will be adjusting the light intensity of two LED's connected to pin 5, and 6. A push button on pin 10 is used to step through various intensity levels.

.. figure:: ../../fig/digital_input_and_output_bb.png
        :align: center
        :scale: 50


.. note::
   Logic Analyzer, or scope demonstration.

.. ref: https://www.instructables.com/id/Arduino-How-to-Control-Servo-Motor-With-Potentiome/


.. todo:: Add solution after the lecture

#. Connect the push button, and the two LEDs in accordance with the schematic.
#. Write a program which toggles evenly between 5 levels of light intensity (from 0 to 255) by the pushing of the button. Both LEDs should have the same intensity, starting at 0, and ending at 255.
#. Extend the program such that after reaching maximum intensity, another push of the button resets the intensity back to 0.
#. Extend the program such that while one LED is stepping down, the other is stepping up in intensity. After reaching maximum (or minimum) intensity, the direction should change.


.. rubric:: Footnotes

.. [#f2] Arduino Cookbook by Michael Margolis Chapter 2.



Functions
=================

*Functions* are used to organize the actions performed by your software into functional blocks. Functions package functionality into well-defined *inputs* (information given to a function) and *outputs* (information provided by a function) that make it easier to structure, maintain, and reuse your code. You are already familiar with the two functions that are in every Arduino firmware: :code:`setup` and :code:`loop`. You create a function by declaring its return type (the information it provides), its name, and any optional parameters (values that the function will receive when it is called). [#f2]_

.. note:: The terms functions and methods are used to refer to well-defined blocks of code that can be called as a single entity by other parts of a program. The C language refers to these as functions. Object-oriented languages such as C++ that expose functionality through classes tend to use the term method. Arduino uses a mix of styles (the example sketches tend to use C-like style, libraries tend to be written to expose C++ class methods). We will normally use the term *function*, unless the code is exposed through a class. Don’t worry; if that distinction is not clear to you, treat both terms as the same.

..
    Let's write a simple function that just blinks an LED. It has no parameters and doesn’t return anything (the void preceding the function indicates that nothing will be returned):

    **Practical example:** Blink an LED once function

    We can also tell the function how many times the LED should blink as an *input parameter*.

    **Practical example:** Blink an LED the number of times given in the count parameter

    .. seealso:: ANOUNCE ONLY IF ANY EXPERIENCED PROGRAMMER IN THE CLASS!!

    Experienced programmers will note that both functions could be blink because the compiler will differentiate them by the type of values used for the parameter. This behavior is called function overloading. 

    A parameter is sometimes referred to as an argument in some documentation. For practical purposes, you can treat these terms as meaning the same thing. I may use them both in various places.

    Time to implement *function* concept into our previous blinking code. We can expand the idea a little bit. Let's demonstrate calling a function with a parameter and returning a value. Use the same wiring as the previous exercise. The LED flashes when the program starts and stops when a switch is pressed.

    **Practical example:** Blink an LED the number of times given in the count parameter. The program prints the number of times that the LED flashes.

A parameter is sometimes referred to as an argument in some documentation. For practical purposes, you can treat these terms as meaning the same thing. We will use them interchangeably here.

.. I may use them both in various places.

No input no output
--------------------

In mathematic a function which takes no input, and provide no output makes no sense. In our software however it does make sense because here a function can have side effects. I.e. it can affect something outside of the function call, such as a digital output, a memory location, or it can simply block forcing us to wait for a while. E.g. a function :code:`delay_one_second()` could be defined which block for one second (though we would not recommend this, or consider it a good practice).

Actually, even if the function takes no parameters, the function call can be considered the simples possible parameter. The call will happen on a specific instant in your code, and this will affect the instant at which the side effects of the function.

.. code-block:: c

    const int ledPin = 2;

    void setup() {
        Serial.begin(9600);
        pinMode(ledPin, OUTPUT);
    }

    void loop() {
        my_func_on();
        delay(500);
        my_func_off();
        delay(500);
    }

    void my_func_on(){
        digitalWrite(ledPin, HIGH);
    }

    void my_func_off(){
        digitalWrite(ledPin, LOW);
    }


.. **Note:** change integer value in function and observe that it doesn't change if it is defined as local.

No output but with input
--------------------------

.. bool: c/c++

.. boolean: Arduino

.. code-block:: c

    const int ledPin = 2;
    bool ledState = false;

    void setup() {
        Serial.begin(9600);
        pinMode(ledPin, OUTPUT);
    }

    void loop() {
        my_func(ledState);
        ledState = !ledState;
        delay(500);
    }

    void my_func(bool state){
        digitalWrite(ledPin, state);
    }

    void my_nosense_func(int a){
        a = 5;
    }

Integer return
---------------

The following code demonstrate how to define a function which is capable of returning a single integer. It is a silly function which always returns 5, regardless of what value you try to pass as a parameter.

.. code-block:: c

    int my_meaningful_func(int a){
        a = 5;
        return a;
    }


The basic functions in C are only able to return a single value. You can return multiple values but it is a bit more advanced topic which require utilizing some features on the language which we have not discussed so far.



Exercise: Pythagoras
---------------------------------

#. Declare, and define a function which computes the hypotenuse of a right angled rectangle given the length of the two other sides. The function should take two arguments of type integer, and return a single integer result.
#. Test the function with some data, and print the result to the serial port.

.. 
    seealso::

   .. If there is time, ask students to do a tilt detection should return boolean.


.. .. seealso:: ANOUNCE ONLY IF ANY EXPERIENCED PROGRAMMER IN THE CLASS!!

    Experienced programmers will note that both functions could be blink because the compiler will differentiate them by the type of values used for the parameter. This behavior is called function overloading. 

..
    .. seealso::

    If you wonder `how to return multiple arguments from a function, follow this link <http://nebomusic.net/arduinolessons/Void_and_Return_Functions_with_Arduino.pdf>`_.



Function for debounce of multiple bush buttons
-----------------------------------------------

The previously discussed method for software switch debounce is a good candidate for placement in a function. Switch debounce is almost always needed when using mechanical push buttons on digital inputs, and it makes sense to have the code available for easy reuse. Additionally if designed properly a single function can be used for debounce of multiple digital inputs.

.. literalinclude:: ../../../projects/platformio/debounce/multi-switch-debounce/src/main.cpp
    :language: c
    :linenos:



Loops
================

Loops are the mechanism by which our software is able to perform repetitive tasks.


.. todo:: Don't forget to start with introducing ARRAYs.

.. todo:: Provide syntax for: FOR, WHILE, DO...WHILE, goto

.. code-block:: c

    const int redPin = 3;
    const int greenPin = 5;
    const int bluePin = 6;

    int redVal = 0;

    void setup() {
        Serial.begin(9600);
        pinMode(redPin, OUTPUT);
        pinMode(greenPin, OUTPUT);
        pinMode(bluePin, OUTPUT);
    }

    void loop() {
    // int potVal = analogRead(A0);
    // Serial.println(potVal);
    // int pwmVal = map(potVal, 0, 1023, 0, 255);

    for(redVal=0; redVal<256; redVal++){
        analogWrite(redPin, redVal);
        analogWrite(greenPin, 0);
        analogWrite(bluePin, 0);
        delay(2);
        }

    delay(10);

    }


Exercise: Blink a LED seven times
---------------------------------


#. Write a loop which blinks a LED seven times and then stop. The loops should be placed in a separate function, which is called from :code:`setup()`. A count down should be printed to the serial port.
#. Extend the program to allow initiating the blinking by pushing a button. This time the function should be called from :code:`loop()`.


.. ifconfig:: solution_l4 in ('all')

    .. code-block:: C

        for(uint8_t i = 0; i < 10; i++)
