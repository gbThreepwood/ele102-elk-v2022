.. _L9_communication:

..  .. note:: *11/03/2020 - 195mins*

        **Aim:**

        - I2C, SPI, UART/USART basics
        - they are mostly SoC protocols, low range
        - mention long range ones like RF, Ethernet etc but very basic.
        - why do we need a communication protocol?
        - Teach how to read a Datasheet 
            - IMU
            - NRF
            - MA702
            - Atmega328P
        - you can connect even 2 arduinos !


        **Materials:**

        - Arduino Board
        - Button
        - Cables
        - Breadboard
        - Potentiometer
        - Resistors
        - LED
        - MPU6050
        - NRF24L01 x 2
        - OLED



        **Code:**

        - Ex: NRF LED on/off (connected via SPI)
        - Hw: provide MPU6050 psudo code, make them plot acceleration

.. role:: ccode(code)
        :language: c

*************************************
Communication Protocols
*************************************

A communication protocol is a system of rules governing how two entities are to communicate with each other. Often it is usefull to separate the protocol into various layers, governing different aspects of the communication. Some layers may be general in nature, and applicable to many systems, while others may be very application specific. 

    Why do we need ports?
    *There was a dark era before some protocols are decided...*

    .. image:: ../../fig/port_fuck.jpeg
            :alt: To avoid from mess
            :scale: 100
            :align: center


UART/USART
=====================================
pin numbers, where to use, baud rate, sync vs async


Basically, as most of you know, you are uploading your sketches to the Arduino using a USB cable.  The general name of the underlying protocol that is used is `UART <https://www.wikiwand.com/en/Universal_asynchronous_receiver-transmitter>`_ (or sometimes more generally referred to as  `USART <https://www.wikiwand.com/en/Universal_synchronous_and_asynchronous_receiver-transmitter>`_). 

The USB employs a complicated communication protocol, but drivers on the PC end, and a chip on the Arduino end converts this to a simple UART protocol.

.. warning::
        TODO: Explain the basics of the operation of UART and USART.


UART
----

The UART operates whitout a common clock signal for synchronization, hence the asynchronous part of the name. The sender and receiver is syncronized by means of start and stop signals as part of the data stream.

Higher level protocol layers
----------------------------

The UART as a communication protocol is very basic and puts few constraints on how information should be transmitted. A higher level applicaton specific communication protocol is needed in order to use the UART in a reliable communication system.


Serial terminal emulator software
=================================

Both the standard Arduino IDE, and Visual studio code (with PlatformIO) has built in serial terminal emulators. If however you require more advanced features, different software might be more appropriate.

Minicom is a popular GNU/Linux serial terminal. Refer to the manual for your distribution for instructions on how to install it.

PuTTY is a popular alternative for Windows. You may download it at `putty.org <https://www.putty.org/>`_.


UART communication in Arduino
====================================

This section covers the communication between Arduino and a PC using the single hardware UART available on the Arduino Uno.

.. warning::

    On the Arduino Uno, pins 0 and 1 are used for communication with the computer. Connecting anything to these pins can interfere with that communication, including causing failed uploads to the board.

The Arduino functions associated with writing data to the serial port that we will be using in this tutorial are:

- `Serial.begin() <https://www.arduino.cc/reference/en/language/functions/communication/serial/begin/>`_

- `Serial.write() <https://www.arduino.cc/reference/en/language/functions/communication/serial/write/>`_
- `Serial.print() <https://www.arduino.cc/reference/en/language/functions/communication/serial/print/>`_
- `Serial.println() <https://www.arduino.cc/reference/en/language/functions/communication/serial/println/>`_
- `Serial.availableForWrite() <https://www.arduino.cc/reference/en/language/functions/communication/serial/availableforwrite/>`_

The Arduino functions associated with reading data from the serial port that we will be using in this tutorial are:

- `Serial.read() <https://www.arduino.cc/reference/en/language/functions/communication/serial/read/>`_
- `Serial.readBytes() <https://www.arduino.cc/reference/en/language/functions/communication/serial/readbytes/>`_
- `Serial.readString() <https://www.arduino.cc/reference/en/language/functions/communication/serial/readstring/>`_
- `Serial.readStringUntil() <https://www.arduino.cc/reference/en/language/functions/communication/serial/readstringuntil/>`_
- `Serial.available() <https://www.arduino.cc/reference/en/language/functions/communication/serial/available/>`_
- `Serial.setTimeout() <https://www.arduino.cc/reference/en/language/functions/communication/serial/settimeout/>`_

Serial output
-------------

This section covers the basics of transmission of data from Arduino to a serial terminal on your PC.

Basic serial output example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following example illustates how to transmit "Hello world" over the serial port:

.. code-block:: c

    void setup() {
        Serial.begin(9600); // open the serial port at 9600 bps
    }

    void loop() {
        Serial.println("Hello world"); // text written what you want to see      
        delay(500); // delay 0.5 seconds before the sending
    }




Initialization
~~~~~~~~~~~~~~~~~~~~~~

Before you can use the :ccode:`Serial` object in Arduino it must be initialized with some configuration. Often you will simply see: :ccode:`Serial.begin(9600)`. This configures the serial port for 9600 bits per second, 8 data bits, one start bit, no parity bit, and one stop bit. This configuration is rather common, and thus it is also the default, when you specify nothing. If you want to be explicit, you may use:

.. code-block:: c

        Serial.begin(9600,SERIAL_8N1);

Although the bit configuration is often left alone, it is common to adapt the baudrate (in this context the baudrate is the number of bits per second). In order to specifiy the next higher standard baudrate of 19200, you may use:

.. code-block:: c

        Serial.begin(19200,SERIAL_8N1);

If you wish to use parity, or adjust the number of data bits, there are many predefined configurations. E.g.:

.. code-block:: c
       
        Serial.begin(19200,SERIAL_5E2);

.. warning::
        Unless you understand the implications, and know that you need something else, it is probably best to stay with the default configuration.

The explanation for the semingly arbritary baudrate of 9600 lies in the first applications of this kind of communication systems. Old mechanical teletypewriters operated at 75 baud, and thus some of the first modems also used that speed. Later modems used 150 baud, then 300 baud, and then 1200, 2400, and 9600 baud. All baudrates are multiples of two, which simplified the design, and allowed one system to easily support multiple baudrates.

Some baudrates that are communly supported include:

* 9600
* 19200
* 38400
* 57600
* 115200

The `Serial.write()` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :ccode:`Serial.write()` method writes binary data to the serial port. It is useful for low level writing, when you want the actual number, rather than it's ASCII representation to be written to the terminal.

In order to write a lower case "f" to the terminal you may use:

.. code-block:: c

    Serial.write(102);

or:

.. code-block:: c

    Serial.write("f");

But if you want to write the number 102 (i.e. the integer 102, not the string "102"), such that it is displayed as "102" in the terminal, that number must first be converted to a string. The number is one byte, but it's ASCII representation is three bytes:

.. code-block:: c
    
    Serial.write(49);
    Serial.write(48);
    Serial.write(50);

The :ccode:`Serial.write()` metod stores the data to be transmitted in a buffer, before returning immediately. The actual transmission is handled by a ISR. If the buffer is full however, the method will block until there is sufficient free space. If you cannot afford the risk of the code blocking, you should use the method :ccode:`Serial.availableForWrite()` to check if the buffer has free space before writing.
 
The `Serial.print()` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
The :ccode:`Serial.print()` method simplifies the writing of numbers, as it automatically converts them to ASCII. The following will print the number as ASCII:

.. code-block:: c

    Serial.print(102);

The :ccode:`Serial.print()` method support a parameter specifying how to print a integer:

* :ccode:`Serial.print(154, BIN);` prints 10011010.
* :ccode:`Serial.print(154, OCT);` prints 232.
* :ccode:`Serial.print(154, DEC);` prints 154.
* :ccode:`Serial.print(154, HEX);` prints 9A.

If the passed number is floating point, the second parameter is used to specify how many decimal places to use:

* :ccode:`Serial.print(1.2345, 2);` prints 1.23.
 
The `Serial.println()` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :ccode:`Serial.println()` method works in the same manner as :ccode:`Serial.print()` with the addition of a carrige return and line feed appended at the end.

Serial output of the push button state
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's write a program that takes the button state, and writes it on your serial monitor .

This will look like that with your breadboard and Arduino:

.. figure:: ../../../external/fig/buttonconnect.png
   :align: center

The following code continously prints the state of the push button to the serial port:


.. code-block:: c
    
    #include <Arduino.h>
    
    uint8_t button_pin = 2;
    
    void setup() {
    
      pinMode(button_pin, INPUT);
    
      Serial.begin(9600);
    }
    
    void loop() {
      uint8_t button_state = digitalRead(button_pin);
      Serial.println(button_state);
      delay(1);
    }
      

Serial input
------------

When the Arduino receives data on the serial port the data is automatically stored in a buffer. When the buffer is full, Arduino ignores any new data until the buffer is drained. Several of the functions used to access this buffer, automatically frees the memory.

The Serial.read() method
~~~~~~~~~~~~~~~~~~~~~~~~

In order to read a single byte from the serial port we may use the `Serial.read()` method.
    
.. code-block:: c

    Serial.read();

It is pointless to read the serial port if no data is available, thus we use the `Serial.available()` method to check if there is data in the buffer first.

.. code-block:: c

    Serial.available();

The :ccode:`Serial.read()` method returns "-1" if no data is available on the serial port. This can be used to check if the buffer is empty, but it can also be problematic if one wishes to use it for a binary communication protocol, where the binary code for "-1" could be part of the transmission. 


The following example shows how to read all keystrokes in the terminal, and feed back the ASCII code, as well as the character:

.. code-block:: c
    
    #include <Arduino.h>
    
    void setup() {
      Serial.begin(9600);
      Serial.println("Press any key: ");
    }
    
    void loop() {
    
        uint8_t data;
        
        if(Serial.available()){
            data = Serial.read();
            Serial.print("Data: ");
            Serial.print(data);
            Serial.print(" : Tegn: ");
            Serial.write(data);
            Serial.print("\n");
        }
    }


The Serial.readBytes() method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :ccode:`Serial.readBytes()` method reads one or more bytes from the serial port, and stores them in a specified buffer. The method is blocking until the specified number of bytes are received, or a timeout occurs. The timeout delay is configured by the method :ccode:`Serial.setTimeout()`.

.. code-block:: c
        
        Serial.readBytes(buffer, length)

The binary nature of this function makes it usefull for binary transfers, but more complicated to use for normal text.

The following example reads a maximum of five bytes from the serial port. If five bytes are received, or a timeout occurs, the data is printed back on the serial port.

.. literalinclude:: ../../../projects/serial_read_bytes/src/main.cpp 
        :language: c

The Serial.readString() method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :ccode:`Serial.readString()` method reads one or more bytes from the serial port, and stores them i a specified buffer. The method takes no parameters, and returns on a timeout.

.. code-block:: c

    Serial.readString()

The following example reads data from the serial port until a timeout occurs.

.. literalinclude:: ../../../projects/serial_read_string/src/main.cpp 
        :language: c

The Serial.readStringUntil() method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :ccode:`Serial.readStringUntil()` method reads data from the serial port until it reaches a termination character.

.. code-block:: c
    
    Serial.readStringUntil(terminator)

The following example reads data from the serial port until a newline character is received (i.e. you press ENTER), or a timeout occurs. The data is then written back to the serial port.

.. literalinclude:: ../../../projects/serial_read_string_until/src/main.cpp 
        :language: c

Store the strings in program memory
-----------------------------------

By default the strings you use in your writes to the serial port are stored in RAM. The SRAM in Atmega328P is only 2 kB. If you have lots of text that you wish to send to the serial port, this can quickly consume all of your memory.

To overcome this issue you may store the strings in program memory. There are however some implications to consider.

This fact may seem a bit confusing to anyone that is new to microcontrollers. After all the SRAM is volatile, all it's content is deleted when you reset or power off the microcontroller. Then how can the strings survive the power cycle? The explanation for this is that the strings are stored in program memory, and copied into SRAM during the boot process of the controller. In other words they occupy the same amount of memory in both SRAM, and flash ROM.

This is required because the CPU instruction to read RAM differ from the function (LPM) that read the flash ROM. Any function that supports normal variables will fail to access data from ROM.

You may read more about the various memories in Arduino `here <https://playground.arduino.cc/Learning/Memory/>`_

In order to tell the compiler to store data in program memory you may use the `PROGMEM` modifier:

.. code-block:: c

        const PROGMEM uint16_t testData[] = { 65535, 32000, 12000, 20, 12345};



The following example illustrates how to store and retrieve some numbers, and one string from program memory:

.. literalinclude:: ../../../projects/serial_write_string_from_progmem/src/main.cpp
        :language: c


If all you need is to write a string to the serial port, and you don't want to waste memory the `F()` macro may be used:

.. code-block:: c

        Serial.print(F("This string is constant, thus it is best to store it in FLASH"));


You may read more about how to use the program memory to store data in the `Arduino reference <https://www.arduino.cc/reference/tr/language/variables/utilities/progmem/>`_

Simple command line interface
-----------------------------

In order to interact with the software in the Arduino while it is running, we will create a simple command line interface.

.. literalinclude:: ../../../projects/serial_command_line_interface/src/main.cpp 
    :language: c

Arduino serial port buffer
--------------------------

The Arduio uno has circular RX and TX buffers of 64 bytes. If the buffer is full, incoming data is discarded.


.. code-block:: c
    
    #define SERIAL_TX_BUFFER_SIZE 64
    #define SERIAL_RX_BUFFER_SIZE 64


Connecting two Arduino's using UART
------------------------------------

The following example shows how to communicate between two Ardiuno UNO's using the UART. On each device pin 2 is used for reception (RX), and pin 3 is used for transmission (TX). The TX output of one device is connected to the RX input of the other.

.. figure:: ../../fig/dual_arduino_uart_communication_bb.png
    :scale: 50


.. literalinclude:: ../../../projects/uart/arduino_uart_link/src/main.cpp
    :language: c


Arduino Control via C# application
==================================

In this lesson we will go through the design of a application that allows us to communicate between a desktop application written in C#, and a Arduino application written in C/C++. The communication link will be using the UART, but with some additional higher level application specific protocol layers.

Designing a simple communication protocol on top of UART
--------------------------------------------------------

Among the low level methods that are available to us are `Serial.write()`, and `Serial.read()`. The methods have the ability to send and receive one byte respectively. They do hovever not put any constraints on what the bytes are supposed to represent. The binary value 0b01001011 could represent a uppercase "K", as it does in ASCII, but it could also be a command to turn on a LED, or read a analog input. It is up to the designer to decide.

Even though you are free to do as you please, there are some approaches that are considered good practice, and that often lead to a more reliable communication system.

The following listing is one typical organisation of the data packet: 

* Start flag (single constant byte signifying start of transmission)
* Command byte (one or more bytes that informs the receiver on what the data represents)
* Length byte (the number of data bytes, or possibly the total number of bytes)
* Data byte (the actual data to transfer)
* Checksum or CRC (data used to verify the integrity of the transmitted data)
* End flag (single constant byte signifying end of transmission)

For fixed lengt data packages the length byte is not needed. In simple applications the checksum is often omitted, and possibly also the start and end flags.

For advanced applications there is a possible issue that the start, and end flags could appear as part of the data bytes. If each byte of the data could be anything, that means it could also be the flags no matter which value you choose to use. The flags are introduced to increase reliability, and this benefit is compromized if you do not reset the reception each time you receive a start flag. In order to overcome this issue one may use various forms of byte stuffing.


For production code it is recommended to at least use the following organisation of the data even for simple applications:

* Start flag (single constant byte signifying start of transmission)
* Command byte (one or more bytes that informs the receiver on what the data represents)
* Data byte (the actual data to transfer)
* End flag (single constant byte signifying end of transmission)

In the following examples we will try to start of even simpler however.


Consistent Overhead Byte Stuffing (COBS)
-----------------------------------------

.. note:: Byte stuffing is a advanced topic, and will not be covered as part of the course. It is here for the students that are particulary curious.

https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing


Using the serial port in C#
===========================

Before we go into the details of how to use the serial port, we should first try to understand the basic concept of delegates, and events.

Delegates
--------------------

A delegate in C# is a variable that holds a reference to a method. This is similar to the function pointer concept in C.

Events
-------

A event could be any occurrence of something. The event system in C# is used to notify one part of the software about something that has happened in a different part of the software. This could for instance be a user pressing a button on the keyboard, or mouse, or it could be data received on the serial port.

The event system works by the publisher-subscriber model. A publisher allows one or more subscribers to subscribe to the available events, when a event is raised, a method in the subscriber is called.

The subscribers are added to the publisher by assigning methods to a delegate variable in the publisher.

.. code-block:: c

  using System;
  
  namespace EventsDelegatesTest
  {
      class MainClass
      {
          public static void Main(string[] args)
          {
              var video = new Video() { Title = "Back to the future" };
              VideoEncoder videoEncoder = new VideoEncoder();
              var smsServie = new SMS();
  
              videoEncoder.VideoEncoded += smsServie.OnVideoEncoded;
              videoEncoder.VideoEncodingStarted += smsServie.OnStartEncoding;
  
              videoEncoder.Encode(video);
              Console.WriteLine("Programmet er ferdig.");
          }
      }
  
  }



.. code-block:: c

  using System;
  
  namespace EventsDelegatesTest
  {
      public class VideoEventArgs : EventArgs
      {
          public Video Video { get; set; }
      }
      public class VideoEncoder
      {
          public delegate void VideoEncodedEventHandler(object source, VideoEventArgs args);
          public delegate void VideoEncodingStartedHandler(object source, EventArgs args);
  
          public event VideoEncodedEventHandler VideoEncoded;
          public event VideoEncodingStartedHandler VideoEncodingStarted;
  
          public void Encode(Video video)
          {
              OnVideoEncodingStarted();
  
              Console.WriteLine("Enkodar video..");
  
              OnVideoEncoded(video);
          }
  
          protected virtual void OnVideoEncoded(Video video)
          {
              if (VideoEncoded != null)
              {
                  VideoEncoded(this, new VideoEventArgs() { Video = video });
              }
          }
          protected virtual void OnVideoEncodingStarted()
          {
              if(VideoEncodingStarted != null)
              {
                  VideoEncodingStarted(this, EventArgs.Empty);
              }
          }
      }
  }

.. code-block:: c
  
  using System;
  namespace EventsDelegatesTest
  {
      public class SMS
      {
          public void OnStartEncoding(object source, EventArgs e)
          {
              Console.Write("Kodinga har starta.");
          }
          public void OnVideoEncoded(object source, EventArgs e)
          {
              Console.WriteLine("Sender SMS...");
          }
      }
  }


Using the serial port in C# (System.IO.Ports)
---------------------------------------------

When reading the serial port you have several options. You could use a blocking call that blocks until data is available on the serial port, or you could poll the serial port library to check if data is available. Finally you could register a event handler that is called when data is available.


Simple example
==============

In this example we wil create a application to control an LED, and read a analog value from a potmeter connected to our Arduino.

.. figure:: ../../fig/one_potmeter_and_one_led_bb.png
  :scale: 50


Arduino software
----------------

Ideally you should not have to concern yourself with what kind of programming language will be used on one side of the communication link, when developing software on the other side. In our case that means that you should not need to know C# in order to develop the Arduino software, and you should not have to know C or Arduino in order to develop the C# software.

For this to work you should write a protocol specification before you start developing the software. In this first approach the following protocol is implemented (please note that this is a very naive approach):

Command: 'led' causes a LED on pin 9 to toggle. Command 'voltage' causes the Arduino to return the measured raw analog value on pin A0. No additional control data is transmitted, the controller does not return a confirmation message when it is told to toggle the LED, and the reception relies on a timeout insted of a end flag to signify complete data packet.

One could also note that the data is transmitted as ASCII, which means that a number that ideally takes up one byte, will use two bytes. And also the length of the commands are many bytes, which introduces unnecessary overhead.


.. literalinclude:: ../../../projects/remote_control/simple_arduino_slave/src/main.cpp
  :language: c


C# software
-----------

.. figure:: ../../fig/software/arduino_comm_screenshot.png
  :scale: 100


Improved example
================


For this improved example we will be using an ASCII based communication protocol. I.e. the data that appear on the UART should be readable when converted to it's character representation in the ASCII code. This introduces some overhead, but has the advantage that the protocol is easy to debug, and it is also testable using a simple UART serial terminal on a PC.

* # - Start flag
* <byte> 
* <byte>
* \n - End flag



Debugger
--------

The serial port is often used to print debug messages. When developing an application that uses the serial port for other purposes, it is no longer available for debugging. Arduino UNO contains only one hardware UART, but you can extend your application with software UART's.

The following Arduino program implements a simple bridge between a software UART, and a hardware UART. The software is intended to run on a additional Arduino, to aid in debugging of the code on our primary Arduino. The hardware UART is connected to a PC using USB, while the software UART is connected the the Arduino under test. The allows the Aruino under test to send debug messages using a software UART of it's own.

.. figure:: ../../fig/one_potmeter_and_one_led_with_debugger_bb.png
  :scale: 50

.. literalinclude:: ../../../projects/remote_control/arduino_softserial_debugger/src/main.cpp
  :language: c


Arduino software
-----------------

.. literalinclude:: ../../../projects/remote_control/improved_arduino_slave/src/main.cpp
  :language: c


C# software
-----------

Advanced example
================

.. figure:: ../../fig/one_potmeter_and_three_led_bb.png
  :scale: 50


Arduino software
----------------


C# software
-----------

.. figure:: ../../fig/software/adv_arduino_comm_screenshot.png
  :scale: 100 
